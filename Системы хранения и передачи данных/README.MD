# Домашнее задание к занятию "`Базы данных, их типы`" - `Гаврилова Валерия`

### Задание 1

1.1. Бюджетирование и финансы

Для бюджета, отчетов и прогнозирования критически важна точность, никаких потерь данных и чёткая структура. Для этих задач подходит классическая реляционная база (SQL), типа PostgreSQL или Microsoft SQL Server.

Если хеширование (например, шифрование паролей) стало тормозить: Можно поручить эту задачу специальным облачным сервисам от AWS или Google Cloud, которые заточены под быстрые криптографические операции. Или просто кэшировать результаты, чтобы не вычислять каждый раз заново.

1.2. Лендинги и CRM

Лендинги — сайты-одностраничники, куда приходят потенциальные клиенты. Данные могут быть разными, структура часто меняется. Нужна скорость. MongoDB (гибкая документная база) идеально для этого подходит. CRM — система для менеджеров по продажам. Там уже больше порядка, но тоже нужна гибкость. Для CRM — можно тоже реляционную (PostgreSQL) или современную гибридную.

PostgreSQL умеет хранить и строгие таблицы (для CRM), и гибкие документы в формате JSON (для данных с лендингов). Он подойдет для обетх этих задач. Это будет удобно и для разработки, и для анализа.

1.3. База знаний компании (нормы, правила, обучение)

Хранить документы, инструкции, обучающие материалы нужно так, чтобы было понятно, к какому отделу что относится. На самом деле, сойдёт та же реляционная база (например, PostgreSQL). В ней можно создать таблицу "Документы" и указывать для каждого документа его "родительский" раздел. Получится понятное древо.

Можно использовать уже существующую базу. Если для финансов или CRM уже стоит PostgreSQL, то можно создать в ней отдельный набор таблиц для этих корпоративных знаний. Это проще и дешевле, чем ставить новую систему.

1.4. Логистика (маршруты доставки, курьеры)

Строить оптимальные маршруты между объектами, быстро находить связи (какой склад ближе к стройке, какого курьера назначить). Здесь важны именно связи между точками. Лучше всего — графовая база данных (например, Neo4j). Она мыслит именно категориями "точек" и "связей" между ними, что идеально для маршрутизации.

Лучше подключить отдел закупок отдельно, но связать. Закупки — это больше про учёт материалов, поставщиков, договоры. Им удобнее в реляционной базе. Но их база должна быть тесно интегрирована с логистической, чтобы при формировании маршрута сразу было видно, какой материал откуда везти. Можно использовать разные специализированные системы, которые общаются между собой через общий интерфейс (API).

1.5. А можно ли вообще всё сделать на одной базе данных?

Технически — да. Универсальная база вроде PostgreSQL справится со всеми задачами: финансами, CRM и лендингами, базой знаний, логистикой.

Но если компания большая и задачи серьёзные, часто разумнее выбрать 2-3 разные базы, идеально заточенные под свои цели (например, PostgreSQL для структурированных данных и Neo4j для логистики), и научить их общаться между собой. Это даст большую производительность и гибкость в долгосрочной перспективе.

---

### Задание 2
 2.1. Обычное пополнение баланса (пользователь сам инициирует)
- Инициирование: Система (приложение или сайт оператора) создаёт новую «транзакцию» — временную рабочую область, где все изменения будут промежуточными, пока всё не завершится.
- Проверка платёжного шлюза: Приложение связывается с платёжной системой (банк, Qiwi и т.п.), передаёт данные карты и сумму, и запрашивает предварительную проверку и блокировку этой суммы на счёте пользователя. Деньги пока не списаны, но они «заморожены».
- Подтверждение оплаты: Пользователь вводит CVC/CVV-код или подтверждает платёж в банковском приложении (3-D Secure). Платёжный шлюз окончательно списывает заблокированные деньги и присылает оператору сигнал «Оплата прошла успешно».
- Зачисление на счёт: Получив подтверждение, система оператора добавляет сумму пополнения к текущему балансу телефонного номера в базе данных.
- Фиксация операции: В базу данных записывается полная история операции: номер телефона, сумма, дата/время, идентификатор платежа из банка. Это важно для отчётности и возможного возврата.
- Завершение транзакции: Система фиксирует (commit) всю операцию. Все промежуточные изменения (новый баланс и запись в истории) становятся постоянными. Пользователь получает уведомление об успешном пополенеии
Если на любом из этих шагов (особенно между 2 и 4) что-то пошло не так (например, отключили свет в дата-центре), система откатит (rollback) все незавершённые изменения. Деньги либо не спишутся, либо (если уже списались) будет запущен процесс возврата, а баланс телефона не изменится.

2.1.* Пополнение через автоплатёж (по расписанию)

Здесь система действует автоматически, но этапы схожи, просто добавляется «подготовительная фаза».
- Срабатывание триггера: В заранее назначенную дату система планировщика видит: «У пользователя X активирован автоплатёж на сумму Y».
- Предварительная проверка: Система перед списанием может проверить несколько условий: Активна ли услуга «Автоплатёж» у пользователя? Не изменился ли тариф/порог для автоплатежа? Достаточно ли средств для пополнения? (Это проверка на стороне оператора, чтобы не беспокоить банк впустую).
- Начало транзакции и запрос в банк: Как и в обычном случае, начинается транзакция, и система отправляет в банк (по сохранённому токену карты, а не по её полным данным) запрос на списание фиксированной суммы.
- Обработка результата от банка: Это ключевой момент. Если банк подтвердил списание система зачисляет деньги на баланс, фиксирует операцию и отправляет уведомление. Если банк отказал (например из-за недостатка денежных средств) система не зачисляет деньги, фиксирует в истории «Автоплатёж не выполнен», завершает транзакцию отказом.
- Уведомление пользователя: Пользователю приходит СМС либо о успешном пополнении, либо о неудаче с просьбой обновить данные для автоплатежа.
- Логирование для повторной попытки: В случае неудачи система может запланировать повторную попытку через день или два (в зависимости от правил оператора).

Главное отличие автоплатежа в том, что процесс полностью автоматический, инициированный системой, а не человеком. Поэтому важна логика обработки отказов со стороны банка, чтобы не создавать ошибочных списаний или долгов.

---

### Задание 3
3.1. Пять ключевых преимуществ SQL-систем перед NoSQL
1. Гарантированная целостность данных (ACID). Это главный козырь. Транзакции в SQL либо выполняются целиком, либо откатываются. Если вы переводите деньги со счёта А на счёт Б, система гарантирует, что деньги и спишутся, и зачислятся. В NoSQL (за редким исключением) такое поведение либо отсутствует, либо его сложно реализовать. Для финансов, заказов, инвентаря — это критически важно.
2. Единая, чёткая и жёсткая схема данных. Все данные хранятся в строго определённых таблицах с заранее заданными столбцами и типами данных (число, текст, дата). Это не позволяет внести в поле "дата рождения" текст или оставить обязательное поле "номер счёта" пустым. Такая схема защищает от мусора в данных и упрощает разработку, когда структура бизнес-объектов (клиент, заказ, товар) стабильна и понятна.
3. Мощный и стандартизированный язык запросов (SQL). Один язык для всего: выборки, вставки, обновления, удаления, создания структур, управления доступом. Он декларативный: вы описываете что нужно получить, а система сама решает как это сделать оптимально. Сложные выборки с соединениями (JOIN) 5-7 таблиц, агрегацией и фильтрацией — родная стихия SQL. В NoSQL подходы к запросам разнятся от системы к системе и часто менее выразительны для сложных связей.
4. Универсальность и зрелость экосистемы. Реляционные СУБД существуют с 70-х годов. Вокруг них выросли горы инструментов: системы BI и отчётности (Tableau, Power BI), ORM (Hibernate, SQLAlchemy), средства миграции и версионирования схемы (Liquibase, Flyway). Найти разработчика, DBA или готовое решение для типовой задачи на SQL-основе в разы проще.
5. Связи и непротиворечивость через внешние ключи (Foreign Keys). Механизм внешних ключей не позволяет удалить запись, на которую есть ссылки из других таблиц (например, нельзя удалить "город", если в нём живут "клиенты"). Это автоматически поддерживает ссылочную целостность на уровне базы данных, избавляя приложение от кучи проверок и потенциальных ошибок. NoSQL обычно перекладывает эту ответственность на код приложения.

3.1.* Преимущества NewSQL перед SQL и NoSQL
Преимущества NewSQL перед классическим SQL:
- Горизонтальное масштабирование (шардирование) "из коробки". Если нагрузка растёт, можно просто добавить новые сервера в кластер, и система сама распределяет данные и запросы между ними. Классические SQL-системы (как PostgreSQL или MySQL) масштабируются вертикально (более мощный сервер) или требуют крайне сложной ручной настройки шардирования.
- Высокая производительность на запись при распределённой архитектуре. Системы вроде Google Spanner или YugabyteDB используют распределённые consensus-алгоритмы (как Paxos, Raft) для работы с данными на многих узлах, сохраняя при этом согласованность. Это позволяет обрабатывать огромные объемы транзакций в реальном времени в глобальном масштабе.
Преимущества NewSQL перед NoSQL:
- Полноценные распределённые ACID-транзакции. Можно выполнять сложные транзакции, затрагивающие данные на разных серверах (шардах), с полными гарантиями атомарности и согласованности. В NoSQL такие транзакции либо отсутствуют, либо ограничены одной партицией/шардом.
- Поддержка SQL и сложных JOIN. Можно использовать привычный, мощный SQL для запросов, включая соединения между таблицами, даже если эти таблицы физически расположены на разных узлах кластера. Многие NoSQL-системы либо не поддерживают JOIN'ы вовсе, либо их реализация очень ограничена.
- Единая схема данных и целостность. Как и в классическом SQL, данные структурированы, что обеспечивает их качество и предсказуемость, в отличие от часто "всёдопускающей" схемы NoSQL.

---

### Задание 4
Критерии выбора типа СУБД:
1. Тип рабочей нагрузки и характер вычислений — основной критерий.
- Для сложной аналитики (OLAP) и агрегаций: Нужны колоночные СУБД (ClickHouse, Apache Druid, Google BigQuery). Они хранят данные по столбцам, что дает сверхбыстрое выполнение запросов на суммирование, усреднение и группировку.
- Для операционной обработки транзакций (OLTP) в распределенной среде: Подойдут NewSQL-системы (Google Spanner, YugabyteDB), которые сочетают горизонтальную масштабируемость с поддержкой ACID-транзакций и SQL.
- Для работы с неструктурированными потоками событий (логи, телеметрия): Используются ширококолонные или документные NoSQL-базы (Apache Cassandra, MongoDB) для быстрой записи и гибкой схемы.
2. Модель согласованности данных (Consistency Model).
- Нужны ли строгие ACID-гарантии для финансовых расчетов? Выбирайте NewSQL или традиционные SQL с шардированием.
- Допустима ли eventual consistency (например, для логов просмотров страниц)? Тогда подойдут NoSQL-системы с их высокой доступностью и распределенностью.
3. Схема данных и её изменчивость.
- Жесткая, заранее известная схема (финансовые проводки) — реляционные (SQL/NewSQL) системы.
- Гибкая, evolving-схема (сырые события с датчиков) — документные (MongoDB) или wide-column (Cassandra) хранилища.
4. Горизонтальная масштабируемость "из коробки".
- Критически важно для 1000 машин. NoSQL и NewSQL проектируются для легкого добавления узлов. Классические SQL системы (PostgreSQL, MySQL) требуют сложной ручной настройки шардирования и часто становятся операционной проблемой.
5. Поддержка распределенных вычислений внутри СУБД.
- Некоторые современные СУБД (например, Greenplum, CockroachDB) имеют встроенные механизмы распределенного выполнения запросов. В других случаях СУБД выступает лишь как хранилище, а вычисления выносятся в отдельный слой (например, Spark).

Для кластера из 1000 машин лучшим выбором будет Apache Spark (как эволюция модели MapReduce) и парадигма Dataflow.

Почему именно Apache Spark:
1. In-Memory вычисления: Spark сохраняет промежуточные данные в оперативной памяти, а не на диске, что на порядки ускоряет итеративные алгоритмы (машинное обучение, графовые алгоритмы) и цепочки преобразований (ETL). Для "большого количества вычислений" это решающее преимущество.
2. Единая платформа для разных парадигм:
- Spark SQL — для выполнения SQL-запросов к структурированным данным.
- Spark Streaming (Structured Streaming) — для обработки потоков данных в реальном времени (микробатчами).
- MLlib — для распределенного машинного обучения.
- GraphX — для графовых вычислений.
Это позволяет решать разнородные задачи в одной экосистеме.
3. Улучшенная модель исполнения: В отличие от жесткой двухфазной модели MapReduce (Map-Shuffle-Reduce), Spark строит Directed Acyclic Graph (DAG) операций и оптимизирует его план выполнения, минимизируя перемещения данных по сети (data shuffling).
4. Отказоустойчивость и локализация данных: Как и MapReduce, Spark автоматически перезапускает упавшие задачи. Он также стремится выполнять код там, где лежат данные, что критично для такого большого кластера.

Выбор СУБД зависит от типа данных и запросов, но для самих распределенных вычислений на таком масштабе Apache Spark является оптимальным выбором благодаря своей универсальности, производительности (in-memory) и богатой экосистеме.

---
